/*     _              _ _
 *  __| |_ _ ___ _ __( |_)_ _
 * / _` | '_/ _ \ '_ \/| | ' \
 * \__,_|_| \___/ .__/ |_|_||_| dropin-compiler - WebAssembly
 *              |_|
 * Copyright Â© 2019-2024 Blue Forest
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

// Generated by `wit-bindgen` 0.24.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod blueforest {
  #[allow(dead_code)]
  pub mod dropin {
    #[allow(dead_code, clippy::all)]
    pub mod ir {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() =
        super::super::super::__link_custom_section_describing_imports;
      #[derive(Clone, Copy)]
      pub enum Expression {
        Value,
      }
      impl ::core::fmt::Debug for Expression {
        fn fmt(
          &self,
          f: &mut ::core::fmt::Formatter<'_>,
        ) -> ::core::fmt::Result {
          match self {
            Expression::Value => f.debug_tuple("Expression::Value").finish(),
          }
        }
      }
    }
  }
}
#[allow(dead_code)]
pub mod exports {
  #[allow(dead_code)]
  pub mod blueforest {
    #[allow(dead_code)]
    pub mod dropin {
      #[allow(dead_code, clippy::all)]
      pub mod parse {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() =
          super::super::super::super::__link_custom_section_describing_imports;
        use super::super::super::super::_rt;
        pub type Expression =
          super::super::super::super::blueforest::dropin::ir::Expression;
        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_parse_cabi<T: Guest>(
          arg0: *mut u8,
          arg1: usize,
          arg2: i32,
          arg3: *mut u8,
          arg4: usize,
        ) -> i32 {
          #[cfg(target_arch = "wasm32")]
          _rt::run_ctors_once();
          let len0 = arg1;
          let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
          let result2 = T::parse(
            _rt::string_lift(bytes0),
            match arg2 {
              0 => None,
              1 => {
                let e = {
                  let len1 = arg4;
                  let bytes1 =
                    _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);

                  _rt::string_lift(bytes1)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            },
          );
          use super::super::super::super::blueforest::dropin::ir::Expression as V3;
          let result4 = match result2 {
            V3::Value => 0i32,
          };
          result4
        }
        pub trait Guest {
          fn parse(
            input: _rt::String,
            main_non_terminal: Option<_rt::String>,
          ) -> Expression;
        }
        #[doc(hidden)]

        macro_rules! __export_blueforest_dropin_parse_cabi{
        ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          #[export_name = "blueforest:dropin/parse#parse"]
          unsafe extern "C" fn export_parse(arg0: *mut u8,arg1: usize,arg2: i32,arg3: *mut u8,arg4: usize,) -> i32 {
            $($path_to_types)*::_export_parse_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
          }
        };);
      }
        #[doc(hidden)]
        pub(crate) use __export_blueforest_dropin_parse_cabi;
      }
    }
  }
}
mod _rt {

  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen_rt::run_ctors_once();
  }
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      String::from_utf8_unchecked(bytes)
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      core::hint::unreachable_unchecked()
    }
  }
  pub use alloc_crate::string::String;
  extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_parser_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::blueforest::dropin::parse::__export_blueforest_dropin_parse_cabi!($ty with_types_in $($path_to_types_root)*::exports::blueforest::dropin::parse);
  )
}
#[doc(inline)]
pub(crate) use __export_parser_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.24.0:parser:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 492] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xef\x02\x01A\x02\x01\
A\x05\x01B\x0b\x01q\x01\x05value\0\0\x04\0\x0aexpression\x03\0\0\x01q\x02\x04tex\
t\x01s\0\x08quantity\x01u\0\x04\0\x03key\x03\0\x02\x01p\x03\x01o\x02s\x04\x01p\x01\
\x01o\x02s\x01\x01p\x07\x01q\x06\x0ddropin-getter\x01\x05\0\x0bdropin-text\x01s\0\
\x0fdropin-quantity\x01u\0\x0edropin-boolean\x01\x7f\0\x0bdropin-list\x01\x06\0\x0d\
dropin-object\x01\x08\0\x04\0\x05value\x03\0\x09\x03\x01\x14blueforest:dropin/ir\
\x05\0\x02\x03\0\0\x0aexpression\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0aexpressio\
n\x03\0\0\x01ks\x01@\x02\x05inputs\x11main-non-terminal\x02\0\x01\x04\0\x05parse\
\x01\x03\x04\x01\x17blueforest:dropin/parse\x05\x02\x04\x01\x18blueforest:dropin\
/parser\x04\0\x0b\x0c\x01\0\x06parser\x03\0\0\0G\x09producers\x01\x0cprocessed-b\
y\x02\x0dwit-component\x070.202.0\x10wit-bindgen-rust\x060.24.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen_rt::maybe_link_cabi_realloc();
}
